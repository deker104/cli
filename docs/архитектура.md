# Архитектура CLI-интерпретатора

## 1. Описание проекта

CLI-интерпретатор — это командная оболочка, реализующая поведение Unix Shell с возможностью:

- Выполнения **встроенных команд**: `echo`, `pwd`, `cat`, `wc`, `grep`, `exit`
- Обработки **пайпов** (`|`) между командами
- **Подстановки переменных** окружения (`$FOO`, `$?`)
- Поддержки **кавычек и экранирования**: `'`, `"`, `\\`
- Запуска **внешних программ**
- Обработки **кодов возврата команд** и проброса ошибок

## 2. Компоненты системы

### 1. `cmd/main.go` — Точка входа, REPL-оболочка
- Запускает цикл: читает ввод → выполняет подстановку → парсит → исполняет
- Завершается при `exit` или EOF
- Возвращает код завершения последней команды

### 2. `internal/parser` — Парсер командной строки
- Разбивает строку на пайпы и аргументы с учётом кавычек/экранирования
- Возвращает `[][]Token`, где `Token` — `{Value, SubstituteEnv}`

### 3. `internal/substitutor` — Подстановщик переменных
- Подставляет значения переменных `$VAR` и `$?`
- Работает только для `SubstituteEnv == true`

### 4. `internal/env` — Менеджер окружения
- Хранит пользовательские переменные
- Делает fallback к `os.Getenv`

### 5. `internal/executor` — Исполнитель команд
- Определяет тип команды (встроенная/внешняя)
- Исполняет пайплайны через `os.Pipe` и `exec.Command`
- Обрабатывает ошибки и возвращает код завершения

## 3. Потоки данных и взаимодействие компонентов

### 1. Ввод и разбор команды

1. `REPL` получает строку ввода  
2. `Substitutor` заменяет переменные окружения  
3. `Parser` разбирает строку:
   - Токенизирует команду
   - Учитывает кавычки и экранирование
   - Формирует структуру команды

Пример:
```bash
echo "Привет, $USER"
````

Обрабатывается как:

* Команда: `echo`
* Аргумент: `"Привет, user_name"`

---

### 2. Исполнение команды

1. Определение типа команды

   * Встроенные (`pwd`, `exit`) обрабатываются внутри `Executor`
   * Внешние (`ls`, `git`) запускаются через `exec.Command`

2. Обработка пайпов

   * `Executor` соединяет команды через `os.Pipe`
   * stdout одной команды → stdin следующей

Пример:

```bash
cat file.txt | grep foo | wc -l
```

---

### 3. Вывод результата

* Последняя команда выводит результат в консоль
* Команды внутри пайпа передают данные по потокам
* Ошибки выводятся в `stderr`

---

### 4. Завершение работы

* `exit` завершает REPL, возвращая `127`
* Последний код возврата доступен через `$?`
* В случае ошибки REPL возвращает код этой ошибки

---

## 4. Константы

* `ExitCode = 127` — специальный код, сигнализирующий REPL о необходимости завершения

## 5. Распределение по пакетам

| Путь                   | Назначение                          |
| ---------------------- | ----------------------------------- |
| `cmd/main.go`          | Главный REPL-цикл                   |
| `internal/parser`      | Парсинг строки                      |
| `internal/substitutor` | Подстановка переменных              |
| `internal/env`         | Работа с окружением                 |
| `internal/executor`    | Встроенные и внешние команды, пайпы |

## 6. Поддержка `grep`

* Регулярные выражения через `regexp`
* Флаги:

  * `-w` — только целые слова
  * `-i` — игнорировать регистр
  * `-A n` — строки после совпадения
* Работа с файлами и потоком stdin

## 7. Диаграмма классов

![Диаграмма](./Диаграмма%20классов.drawio.svg)

